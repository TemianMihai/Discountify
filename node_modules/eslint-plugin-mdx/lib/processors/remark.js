import { getShortLang } from './helpers';
import { markdown } from './markdown';
import { processorOptions } from './options';
export const remark = {
    supportsAutofix: true,
    preprocess(text, filename) {
        if (!processorOptions.lintCodeBlocks) {
            return [text];
        }
        return [
            ...markdown.preprocess(text, filename).map(({ text, filename }) => ({
                text,
                filename: filename.slice(0, filename.lastIndexOf('.')) +
                    '.' +
                    getShortLang(filename, processorOptions.languageMapper),
            })),
            text,
        ];
    },
    postprocess(lintMessages, filename) {
        return markdown.postprocess(lintMessages, filename).map(lintMessage => {
            const { message, ruleId: eslintRuleId, severity: eslintSeverity, } = lintMessage;
            if (eslintRuleId !== 'mdx/remark') {
                return lintMessage;
            }
            const { source, ruleId, reason, severity } = JSON.parse(message);
            return Object.assign(Object.assign({}, lintMessage), { ruleId: `${source}-${ruleId}`, message: reason, severity: Math.max(eslintSeverity, severity) });
        });
    },
};
//# sourceMappingURL=remark.js.map