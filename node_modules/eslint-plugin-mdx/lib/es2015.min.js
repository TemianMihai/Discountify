import{version as e}from"eslint/package.json";import{isJsxNode as t,arrayify as s,DEFAULT_EXTENSIONS as n,MARKDOWN_EXTENSIONS as r,last as o}from"eslint-mdx";import i from"eslint/lib/rules/no-unused-expressions";import c from"path";import a from"vfile";import{cosmiconfigSync as l}from"cosmiconfig";import m from"remark-mdx";import u from"remark-parse";import p from"remark-stringify";import f from"unified";const d={parser:"eslint-mdx",plugins:["mdx"],processor:"mdx/remark"},g={parserOptions:{ecmaFeatures:{impliedStrict:!0}},rules:{"eol-last":"off","no-undef":"off","no-unused-expressions":"off","no-unused-vars":"off","padded-blocks":"off",strict:"off","unicode-bom":"off"}},x=Object.assign(Object.assign({},d),{globals:{React:"readonly"},rules:{"lines-between-class-members":0,"react/jsx-no-undef":[2,{allowGlobals:!0}],"react/react-in-jsx-scope":0}}),h=+e.split(".").slice(0,2).join("."),b=Object.assign(Object.assign({},d),{rules:{"mdx/no-jsx-html-comments":2,"mdx/no-unused-expressions":2,"mdx/remark":1,"no-unused-expressions":0}});if(h>=6.4){const e=[{files:"*.mdx",extends:"plugin:mdx/overrides"},{files:"**/*.{md,mdx}/**",extends:"plugin:mdx/code-blocks"}];try{require.resolve("prettier"),require.resolve("eslint-plugin-prettier"),e.push({files:"*.md",rules:{"prettier/prettier":[2,{parser:"markdown"}]}})}catch(e){}Object.assign(b,{overrides:e})}const j=(e,t={})=>(Array.isArray(e)?e:Object.keys(e)).reduce(((e,t)=>Object.assign(e,{[t]:!1})),t),y={base:d,"code-blocks":g,codeBlocks:g,overrides:x,recommended:b},k={meta:{type:"problem",docs:{description:"Forbid invalid html style comments in jsx block",category:"SyntaxError",recommended:!0},messages:{jsxHtmlComments:"html style comments are invalid in jsx: {{ origin }}"},fixable:"code"},create:e=>({ExpressionStatement(s){const{JSXElementsWithHTMLComments:n}=e.parserServices;if(!t(s.expression)||"Program"!==s.parent.type||!n||0===n.length)return;const r=n.shift();if(r.data.inline)return;const o=r.data.comments;for(const{fixed:t,loc:n,origin:r}of o)e.report({messageId:"jsxHtmlComments",data:{origin:r},loc:n,node:s,fix:e=>e.replaceTextRange([n.start.offset,n.end.offset],t)})}})},O=Object.assign(Object.assign({},i),{create(e){const s=i.create(e);return{ExpressionStatement(e){t(e.expression)&&"Program"===e.parent.type||s.ExpressionStatement(e)}}}}),v=(e,t,s)=>{s&&/^\.\.?([/\\]|$)/.test(e)&&(e=c.resolve(c.dirname(s),e)),t=t.endsWith("-")?t:t+"-";const n=[e,e.startsWith("@")?e.replace("/","/"+t):t+e];let r;for(const e of n)try{return require(e)}catch(e){r||(r=e)}throw r};let S;const w=f().use(u).freeze(),I=(e,t)=>{let n;S||(S=l("remark",{packageProp:"remarkConfig"}).search);try{n=S(e)}catch(t){if("ENOTDIR"!==t.code||!/[/\\]\d+_[^/\\]*\.[\da-z]+$/i.test(e))throw t;try{n=S(c.dirname(e))}catch(e){throw t}}const{plugins:r=[],settings:o}=(null==n?void 0:n.config)||{};try{r.push([require.resolve("remark-lint-file-extension"),!1])}catch(e){}const i=w().use({settings:o}).use(p);return t&&i.use(m),r.reduce(((e,t)=>{const[r,...o]=s(t);return e.use("string"==typeof r?v(r,"remark",n.filepath):r,...o)}),i).freeze()},C={meta:{type:"layout",docs:{description:"Linter integration with remark plugins",category:"Stylistic Issues",recommended:!0},fixable:"code"},create(e){const t=e.getFilename(),s=c.extname(t),o=e.getSourceCode(),i=e.parserOptions,l=n.concat(i.extensions||[]).includes(s),m=r.concat(i.markdownExtensions||[]).includes(s);return{Program(s){if(!l&&!m)return;const n=o.getText(s),r=I(t,l),i=a({path:t,contents:n});try{r.processSync(i)}catch(e){i.messages.includes(e)||(i.message(e).fatal=!0)}for(const{source:t,reason:o,ruleId:c,fatal:a,location:{start:l,end:m}}of i.messages){const i=a?2:null==a?0:1;if(!i)continue;const u={reason:o,source:t,ruleId:c,severity:i};e.report({message:JSON.stringify(u),loc:{start:Object.assign(Object.assign({},l),{column:l.column-1}),end:Object.assign(Object.assign({},m),{column:m.column-1})},node:s,fix(e){if(null==l.offset)return null;const t=[l.offset,null==m.offset?l.offset+1:m.offset],s=n.slice(...t),o=r.processSync(s).toString();return e.replaceTextRange(t,s.endsWith("\n")?o:o.slice(0,-1))}})}}}}},E={"no-jsx-html-comments":k,"no-unused-expressions":O,noJsxHtmlComments:k,noUnusedExpressions:O,remark:C},L=new Set(["eol-last","unicode-bom"]),M={};function $(e,t,s){if(t[e.type]&&t[e.type](e,s),void 0!==e.children){const s=e;for(const e of s.children)$(e,t,s)}}function q(e){const t="\x3c!--",s="--\x3e";if(e.slice(0,t.length)!==t||e.slice(-s.length)!==s)return"";const n=e.slice(t.length,-s.length);return/^(eslint\b|global\s)/u.test(n.trim())?n:""}const T=/^[>\s]*/u;function A(e){return e.position.start.offset-e.position.start.column+1}function H(e,t){return T.exec(e.slice(A(t)))[0]}function J(e,t,s){const n=A(t),r=e.slice(n,t.position.end.offset).split("\n"),o=H(e,t).length,i=[{js:0,md:0}];let c=s.reduce(((e,t)=>e+t.length+1),0),a=n+r[0].length+1;for(let e=0;e+1<r.length;e++){const t=r[e+1],s=T.exec(t)[0].length,n=Math.min(o,s);i.push({js:c,md:a+n-c}),a+=t.length+1,c+=t.length-n+1}return i}function N(e){return e&&!L.has(e.ruleId)}const P={preprocess:function(e,t){const s=w.parse(e),n=[];return M[t]=n,$(s,{code(t,s){const r=[];if(t.lang){let o=s.children.indexOf(t)-1,i=s.children[o];for(;i&&"html"===i.type;){const e=q(i.value);if(!e)break;if("eslint-skip"===e.trim())return;r.unshift(`/*${e}*/`),o--,i=s.children[o]}n.push(Object.assign(Object.assign({},t),{baseIndentText:H(e,t),comments:r,rangeMap:J(e,t,r)}))}}}),n.map(((e,t)=>({filename:`${t}.${e.lang}`,text:[...e.comments,e.value,""].join("\n")})))},postprocess:function(e,t){const s=M[t]||[];return[].concat(...e.map(((e,t)=>{const n=s[t];if(!n)return e;const r=function(e){const t=e.comments.reduce(((e,t)=>e+t.split("\n").length),0),s=e.position.start.line;return function(n){const r=n.line-t;if(r<1)return null;const o={line:r+s,column:n.column+e.position.indent[r-1]-1};Number.isInteger(n.endLine)&&(o.endLine=n.endLine-t+s);const i={};return n.fix&&(i.fix={range:n.fix.range.map((t=>{let s=1;for(;s<e.rangeMap.length&&e.rangeMap[s].js<=t;)s++;return t+e.rangeMap[s-1].md})),text:n.fix.text.replace(/\n/gu,`\n${e.baseIndentText}`)}),Object.assign(Object.assign(Object.assign({},n),o),i)}}(n);return e.map(r).filter(N)})))},supportsAutofix:!0},R={javascript:"js",javascriptreact:"jsx",typescript:"ts",typescriptreact:"tsx",markdown:"md",mdown:"md",mkdn:"md"};function W(e,t){const s=o(e.split("."));if(!1===t)return s;t=Object.assign(Object.assign({},R),t);const n=s.toLowerCase();return t[s]||t[n]||n}const z={},B=Object.keys(require.cache).find((e=>/([/\\])eslint\1lib(?:\1linter){2}\.js$/.test(e)));if(!B)throw new Error("Could not find ESLint Linter in require cache");const F=require(B).Linter,{verify:D}=F.prototype;F.prototype.verify=function(e,t,s){const n=t&&("function"==typeof t.extractConfig?t.extractConfig(void 0===s||"string"==typeof s?s:s.filename):t).settings||{};return z.lintCodeBlocks=!0===n["mdx/code-blocks"],z.languageMapper=n["mdx/language-mapper"],D.call(this,e,t,s)};const G={supportsAutofix:!0,preprocess:(e,t)=>z.lintCodeBlocks?[...P.preprocess(e,t).map((({text:e,filename:t})=>({text:e,filename:t.slice(0,t.lastIndexOf("."))+"."+W(t,z.languageMapper)}))),e]:[e],postprocess:(e,t)=>P.postprocess(e,t).map((e=>{const{message:t,ruleId:s,severity:n}=e;if("mdx/remark"!==s)return e;const{source:r,ruleId:o,reason:i,severity:c}=JSON.parse(t);return Object.assign(Object.assign({},e),{ruleId:`${r}-${o}`,message:i,severity:Math.max(n,c)})}))},U={markdown:P,remark:G};export{R as DEFAULT_LANGUAGE_MAPPER,d as base,g as codeBlocks,y as configs,j as getGlobals,I as getRemarkProcessor,W as getShortLang,k as noJsxHtmlComments,O as noUnusedExpressions,x as overrides,z as processorOptions,U as processors,b as recommended,C as remark,w as remarkProcessor,v as requirePkg,E as rules};
